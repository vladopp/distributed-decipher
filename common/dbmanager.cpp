#include "dbmanager.h"
#include <QSqlTableModel>
#include <QSqlQuery>
#include <QSqlRecord>
#include <ctime>

const static QString DB_TYPE = "QPSQL";
const static QString TABLE_TASKS = "tasks";
const static QString TABLE_TEXTS = "texts";
const static QString COLUMN_ID = "id";
const static QString COLUMN_TEXT_ID = "text_id";
const static QString COLUMN_FROM_KEY = "from_key";
const static QString COLUMN_TO_KEY = "to_key";
const static QString COLUMN_ACCEPTED_TIMESTAMP = "accepted_timestamp";
const static QString COLUMN_BEST_KEY = "best_key";
const static QString COLUMN_CONFIDENCE = "confidence";
const static QString COLUMN_ENCRYPTED_TEXT = "encrypted_text";
const static int FIVE_MINUTES_IN_SECONDS = 5* 60;

/**
 * @brief DBManager::DBManager ctor.
 */
DBManager::DBManager(QString host, QString database, QString username, QString password) :
    host(host), database(database), username(username), password(password)
{
}

/**
 * @brief DBManager::initDbConnection Initialized the connection to the database.
 * @return Returns true if the connection was successfull, false otherwise.
 */
bool DBManager::connect()
{
    db = QSqlDatabase::addDatabase(DB_TYPE);
    db.setHostName(host);
    db.setDatabaseName(database);
    db.setUserName(username);
    db.setPassword(password);

    return db.open();
}

/**
 * @brief DBManager::getUnprocessedTask Gets the next task to be processed. It returns a task that
 * is not finished and accepted by a worker in the last 5 minutes.
 * @return Returns Task object with information about the task, or Task object with 0 as id if there is no such task.
 */
Task DBManager::getUnprocessedTask()
{
    db.transaction();

    QSqlQuery query;
    query.prepare("SELECT * FROM tasks WHERE best_key IS NULL AND (accepted_timestamp IS NULL OR accepted_timestamp < :time) LIMIT 1");
    query.bindValue(":time", std::time(0) - FIVE_MINUTES_IN_SECONDS);
    query.exec();

    if (query.first())
    {
        int task_id = query.value(COLUMN_ID).toInt();
        Task task(task_id,
                  query.value(COLUMN_TEXT_ID).toInt(),
                  query.value(COLUMN_FROM_KEY).toString(),
                  query.value(COLUMN_TO_KEY).toString());

        query.prepare("UPDATE tasks set accepted_timestamp=:time WHERE id=:id");
        query.bindValue(":time", std::time(0));
        query.bindValue(":id", task_id);
        query.exec();

        db.commit();
        return task;
    }

    db.commit();
    return Task(0);
}

/**
 * @brief DBManager::getTextById Gets the encrypted text, referenced by the @id parameter, to be processed.
 * @param id ID of a text.
 * @return Returns a string with the encrypted text to be processed.
 */
QString DBManager::getTextById(int id)
{
    QSqlQuery query;
    query.prepare("SELECT encrypted_text FROM texts WHERE id=:id");
    query.bindValue(":id", id);
    query.exec();

    if (query.first())
    {
        return query.value(0).toString();
    }

    exit(1);
}

/**
 * @brief DBManager::submitTaskResult Submits the result of the task.
 * @param task Task object that contains the result to be submitted.
 */
void DBManager::addTaskResult(const Task& task)
{
    QSqlQuery query;
    query.prepare("UPDATE tasks set best_key=:key, confidence=:conf WHERE id=:id");
    query.bindValue(":key", task.getBestKey());
    query.bindValue(":conf", task.getConfidence());
    query.bindValue(":id", task.getId());

    query.exec();
}

/**
 * @brief DBManager::addNewTask Adds a new task to be processed.
 * @param task The task to be added.
 */
void DBManager::addNewTask(const Task& task)
{
    QSqlTableModel model;
    model.setTable(TABLE_TASKS);
    model.setEditStrategy(QSqlTableModel::OnManualSubmit);

    db.transaction();
    // remove the id column from the model
    // because it will be autogenerated from the database itself
    model.removeColumn(0);

    QSqlRecord record = model.record();
    record.setValue(COLUMN_TEXT_ID, task.getTextId());
    record.setValue(COLUMN_FROM_KEY, task.getFromKey());
    record.setValue(COLUMN_TO_KEY, task.getToKey());
    model.insertRecord(-1, record);
    model.submitAll();
    db.commit();
}

/**
 * @brief DBManager::addNewText adds a new text that should be deciphered
 * @param text The text that should be added
 * @return returns the id at which this text was inserted
 */
int DBManager::addNewText(const QString& text)
{
    QSqlQuery query;
    query.prepare("INSERT INTO texts (encrypted_text) VALUES (:text) RETURNING id");
    query.bindValue(":text", text);
    query.exec();

    if (query.first())
    {
        return query.value("id").toInt();
    }

    return -1;
}

/**
 * @brief DBManager::getBestKey Given an id of a text returns the key with the highest confidence
 */
QPair<QString, double> DBManager::getBestKey(int text_id)
{
    QSqlQuery query;
    query.prepare("SELECT best_key, confidence FROM tasks WHERE text_id=:id ORDER BY confidence DESC LIMIT 1");
    query.bindValue(":id", text_id);
    query.exec();

    QPair<QString, double> result;
    if (query.first())
    {
        result.first = query.value(0).toString();
        result.second = query.value(1).toDouble();
    }

    return result;
}

/**
 * @brief DBManager::closeDbConnection Closes the connection to the database.
 */
void DBManager::closeConnection()
{
    db.close();
}
