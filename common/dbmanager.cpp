#include "dbmanager.h"
#include <QSqlTableModel>
#include <QSqlQuery>
#include <QSqlRecord>
#include <ctime>

const static QString DB_TYPE = "QPSQL";
const static QString TABLE_TASKS = "tasks";
const static QString TABLE_TEXTS = "texts";
const static QString COLUMN_ID = "id";
const static QString COLUMN_TEXT_ID = "text_id";
const static QString COLUMN_FROM_KEY = "from_key";
const static QString COLUMN_TO_KEY = "to_key";
const static QString COLUMN_ACCEPTED_TIMESTAMP = "accepted_timestamp";
const static QString COLUMN_BEST_KEY = "best_key";
const static QString COLUMN_CONFIDENCE = "confidence";
const static QString COLUMN_ENCRYPTED_TEXT = "encrypted_text";


/**
 * @brief DBManager::DBManager ctor.
 */
DBManager::DBManager(QString host, QString database, QString username, QString password) :
    host(host), database(database), username(username), password(password)
{
}

/**
 * @brief DBManager::initDbConnection Initialized the connection to the database.
 * @return Returns true if the connection was successfull, false otherwise.
 */
bool DBManager::connect()
{
    db = QSqlDatabase::addDatabase(DB_TYPE);
    db.setHostName(host);
    db.setDatabaseName(database);
    db.setUserName(username);
    db.setPassword(password);

    return db.open();
}

/**
 * @brief DBManager::getUnprocessedTask Gets the next task to be processed.
 * @return Returns Task object with information about the task, or NULL if there is no such task.
 */
Task DBManager::getUnprocessedTask()
{
    QSqlTableModel model;
    model.setTable(TABLE_TASKS);
    model.setFilter(QString::fromStdString(COLUMN_BEST_KEY.toStdString() + " is null")); //TODO and accepted_timestamp < now() - 5minutes

    // execute in a transaction to ensure that no other worker
    // can take the same task in the meantime
    // take a lock instead of transaction so that the above is true
    db.transaction();
    model.select();

    // get unprocessedx record
    QSqlRecord record = model.record(0);
    record.setValue(COLUMN_ACCEPTED_TIMESTAMP, std::time(0));
    model.setRecord(0, record);
    model.submitAll();
    db.commit();

    Task task(record.value(COLUMN_ID).toInt(),
              record.value(COLUMN_TEXT_ID).toInt(),
              record.value(COLUMN_FROM_KEY).toString(),
              record.value(COLUMN_TO_KEY).toString());
    return task;
}

/**
 * @brief DBManager::getTextById Gets the encrypted text, referenced by the @id parameter, to be processed.
 * @param id ID of a text.
 * @return Returns a string with the encrypted text to be processed.
 */
QString DBManager::getTextById(int id)
{
    QSqlTableModel model;
    model.setTable(TABLE_TEXTS);
    model.setFilter(QString::fromStdString(COLUMN_ID.toStdString() + " = " + std::to_string(id)));

    model.select();
    QSqlRecord record = model.record(0);

    return record.value(COLUMN_ENCRYPTED_TEXT).toString();
}

/**
 * @brief DBManager::getTextId finds the id of the provided text in the db, -1 if there is no such text
 * @param text The text which id should be found.
 * @return The id of the text
 */
int DBManager::getTextId(const QString& text)
{
    QSqlTableModel model;
    model.setTable(TABLE_TEXTS);
    model.setFilter(COLUMN_ENCRYPTED_TEXT + " = '" + text + "'");

    model.select();
    QSqlRecord record = model.record(0);

    // TODO return -1 if no such text
    return record.value(COLUMN_ID).toInt();
}

/**
 * @brief DBManager::submitTaskResult Submits the result of the task.
 * @param task Task object that contains the result to be submitted.
 */
void DBManager::addTaskResult(const Task& task)
{
    QSqlTableModel model;
    model.setTable(TABLE_TASKS);
    model.setFilter(QString::fromStdString(COLUMN_ID.toStdString() + " = " + std::to_string(task.getId())));

    db.transaction();
    model.select();
    model.setEditStrategy(QSqlTableModel::OnManualSubmit);

    QSqlRecord record = model.record(0);
    record.setValue(COLUMN_BEST_KEY, task.getBestKey());
    record.setValue(COLUMN_CONFIDENCE, task.getConfidence());
    model.setRecord(0, record);
    model.submitAll();
    db.commit();
}

/**
 * @brief DBManager::addNewTask Adds a new task to be processed.
 * @param task The task to be added.
 */
void DBManager::addNewTask(const Task& task)
{
    QSqlTableModel model;
    model.setTable(TABLE_TASKS);
    model.setEditStrategy(QSqlTableModel::OnManualSubmit);

    db.transaction();
    // remove the id column from the model
    // because it will be autogenerated from the database itself
    model.removeColumn(0);

    QSqlRecord record = model.record();
    record.setValue(COLUMN_TEXT_ID, task.getTextId());
    record.setValue(COLUMN_FROM_KEY, task.getFromKey());
    record.setValue(COLUMN_TO_KEY, task.getToKey());
    model.insertRecord(-1, record);
    model.submitAll();
    db.commit();
}

/**
 * @brief DBManager::addNewText adds a new text that should be dedciphered
 * @param text The text that should be added
 */
void DBManager::addNewText(const QString& text)
{
    QSqlTableModel model;
    model.setTable(TABLE_TEXTS);
    model.setEditStrategy(QSqlTableModel::OnManualSubmit);

    db.transaction();
    // remove the id column from the model
    // because it will be autogenerated from the database itself
    model.removeColumn(0);

    QSqlRecord record = model.record();
    record.setValue(COLUMN_ENCRYPTED_TEXT, text);
    model.insertRecord(-1, record);
    model.submitAll();
    db.commit();
}

/**
 * @brief DBManager::closeDbConnection Closes the connection to the database.
 */
void DBManager::closeConnection()
{
    db.close();
}
